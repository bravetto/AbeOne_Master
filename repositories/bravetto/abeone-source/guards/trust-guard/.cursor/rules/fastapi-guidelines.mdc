---
globs: main.py,*.py
description: FastAPI development guidelines and patterns for Trust Guard
---

# FastAPI Development Guidelines

## API Design Principles

### Endpoint Structure
All Trust Guard API endpoints follow the pattern:
- `POST /v1/{operation}` for data processing operations
- `GET /v1/{resource}` for data retrieval
- `GET /health` for health checks
- `GET /metrics` for monitoring

### Request/Response Models
Use Pydantic models for all API interactions:

```python
class TextInput(BaseModel):
    """Input model for text analysis."""
    text: str = Field(..., description="The AI-generated text to analyze")
    context: Optional[str] = Field(None, description="Context information")
    metadata: Optional[Dict[str, Any]] = Field(default_factory=dict, description="Additional metadata")
    
    class Config:
        json_schema_extra = {
            "example": {
                "text": "Example text for analysis",
                "context": "Example context",
                "metadata": {"model": "gpt-4", "confidence": 0.85}
            }
        }
```

### Response Models
Always include comprehensive response models with examples:

```python
class ValidationResponse(BaseModel):
    """Comprehensive validation response."""
    overall_score: float = Field(..., description="Overall reliability score (0-100)")
    pattern_detections: Dict[str, float] = Field(..., description="Detection scores for each pattern")
    risk_level: str = Field(..., description="Risk assessment: low/medium/high")
    recommendations: List[str] = Field(..., description="Mitigation recommendations")
    evidence: Dict[str, Any] = Field(..., description="Supporting evidence and metrics")
    processing_time: float = Field(..., description="Processing time in milliseconds")
```

## Middleware and Configuration

### Rate Limiting
Apply rate limiting to all processing endpoints:

```python
@limiter.limit(f"{config.rate_limit}/minute")
async def endpoint_function(request_data: Model):
    # Implementation
```

### CORS Configuration
Configure CORS for cross-origin requests:

```python
if config.cors_origins:
    app.add_middleware(
        CORSMiddleware,
        allow_origins=config.cors_origins.split(","),
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
```

### Request Logging Middleware
Log all requests with Trust Guard context:

```python
@app.middleware("http")
async def log_requests(request: Request, call_next):
    start_time = time.time()
    # Log request details
    response = await call_next(request)
    process_time = (time.time() - start_time) * 1000
    # Log response with processing time
    response.headers["X-Process-Time"] = str(process_time)
    response.headers["X-Trust-Guard-Version"] = "1.0.0"
    return response
```

## Error Handling

### HTTP Exceptions
Use appropriate HTTP status codes:

```python
try:
    result = await process_request(data)
    return result
except ValidationError as e:
    raise HTTPException(status_code=400, detail=f"Validation failed: {str(e)}")
except ProcessingError as e:
    raise HTTPException(status_code=500, detail=f"Processing failed: {str(e)}")
```

### Error Response Format
Maintain consistent error response format:

```python
{
    "detail": "Error description",
    "error_code": "SPECIFIC_ERROR_CODE",
    "timestamp": "2024-01-01T00:00:00Z"
}
```

## Health Checks

### Comprehensive Health Response
Include component status and metrics:

```python
@app.get("/health", response_model=HealthResponse)
async def health_check():
    return HealthResponse(
        status="healthy",
        version="1.0.0",
        components={
            "detector": detector.is_healthy(),
            "validator": validator.is_healthy(),
            "constitutional": constitutional.is_healthy(),
            "metrics": True
        },
        metrics={
            "uptime_seconds": time.time() - psutil.Process().create_time(),
            "cpu_usage": psutil.cpu_percent(interval=0.1),
            "memory_mb": psutil.virtual_memory().used / 1024 / 1024,
            "patterns_detected_today": metrics.get_patterns_detected_today()
        }
    )
```

## Metrics Integration

### Prometheus Metrics
Enable Prometheus instrumentation:

```python
if config.enable_metrics:
    instrumentator = Instrumentator().instrument(app).expose(app)
```

### Custom Metrics Endpoint
Provide comprehensive service metrics:

```python
@app.get("/v1/metrics")
async def get_service_metrics():
    return {
        "service_health": {
            "detector_status": detector.is_healthy(),
            "validator_status": validator.is_healthy(),
            "constitutional_status": constitutional.is_healthy()
        },
        "performance_metrics": {
            "total_validations": metrics.get_total_validations(),
            "average_risk_score": metrics.get_average_risk_score()
        },
        "pattern_statistics": metrics.get_pattern_statistics()
    }
```

## Performance Considerations

### Async Operations
Use async/await for all I/O operations:

```python
async def process_text_async(text: str) -> Dict[str, Any]:
    # Async processing
    result = await asyncio.gather(
        detect_patterns(text),
        validate_response(text),
        calculate_metrics(text)
    )
    return combine_results(result)
```

### Background Tasks
Use FastAPI BackgroundTasks for non-critical operations:

```python
async def endpoint_with_background_task(
    request_data: Model,
    background_tasks: BackgroundTasks
):
    result = await process_request(request_data)
    background_tasks.add_task(update_metrics, result)
    return result
```

## Security

### Input Validation
Validate all inputs using Pydantic models with appropriate constraints:

```python
class TextInput(BaseModel):
    text: str = Field(..., min_length=10, max_length=8000, description="Text to analyze")
    context: Optional[str] = Field(None, max_length=2000, description="Context information")
```

### API Key Authentication
Implement API key authentication when required:

```python
async def verify_api_key(request: Request):
    if config.api_key:
        provided_key = request.headers.get("X-API-Key")
        if provided_key != config.api_key:
            raise HTTPException(status_code=401, detail="Invalid API key")
```